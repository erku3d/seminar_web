<!DOCTYPE html>
<html>
<head>
  <title>Proseminar Web Engineering im Sommersemester 2014 - Store in the Cloud or not in the Cloud</title>
  <link rel="stylesheet" type="text/css" href="main.css"/>
  <link href='http://fonts.googleapis.com/css?family=Source+Serif+Pro:400,600,700' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
</head>
<body>
    <header>
        <h2>Proseminar Web Engineering im Wintersemester 2015/16</h2>
		<h1>Rust in the Web</h1>
        <h2 class="author">Eric Kunze</h2>
		<h3 class="affiliation">
			Professur Verteilte und Selbstorganisierende Rechnersysteme<br/>
			Technische Universität Chemnitz<br/>
			Chemnitz, Deutschland
		</h3>
    </header>
    <section>
		<p> &nbsp;</p>
		<h2>Inhalt</h2>
		<h3><a href="#sec1">1. Einleitung</a></h3>
		<h3><a href="#sec2">2. Ziel von Rust</a></h3>
		<h3><a href="#sec3">3. Ownership and Borrowing</a></h3>
		<h3><a href="#sec4">4. Vor- und Nachteile</a></h3>
		<h3><a href="#sec5">5. Rust in the Web</a></h3>
		<h3><a href="#sec6">6. Iron</a></h3>
		<h3><a href="#sec7">7. Demo</a></h3>
		<h3><a href="#sec8">8. Fazit</a></h3>
		<h3><a href="#sec9">9. Literaturverzeichnis</a></h3>	
		<p> &nbsp;</p>
    </section>
    <section id="sec1">
    	<h2>1. Einleitung</h2>
        <p>
<!--
    	 It started as a Graydon Hoare's part-time side project in 2006 and remained so for over 3 years. Mozilla got involved in 2009 once the language was mature enough to run some basic tests and demonstrate the idea. Though it is sponsored by Mozilla, Rust is developed by a diverse community of enthusiasts.
-->
		Rust wurde 2006 von Graydon Hoar entwickelt. 2009, als die Sprache so weit entwickelt war, dass man mit ihr einige Test durchführen und die Grundidee dahinter demonstrieren konnte, wurde das Projekt von Mozilla unterstützt <a href="#r4">[4]</a>. Die Version 1.0 der Sprache wurde am 15.05.2015 veröffentlicht <a href="#r5">[5]</a>. <br>
<!--
    	Mozilla intends to use Rust as a platform for prototyping experimental browser architectures. Specifically, the hope is to develop a browser that is more amenable to parallelization than existing ones, while also being less prone to common C++ coding errors that result in security exploits. The name of that project is Servo.
-->
    	Bei Mozilla wird Rust vor allem zur Entwicklung von Prototypen neuer Webbrowserarchitekturen verwendet. Dabei soll verstärkt parallele Programmierung genutzt werden und diese sollen auch weniger anfällig für Sicherheitslücken sein, die beispielsweise durch C++ Programmierfehler entstehen können <a href="#r4">[4]</a>.
    	
    	<!-- TODO evtl. noch einen Satz zum c++ Speichermodell -->
    	<!--An einen Webbrowser werden besondere Anforderungen hinsichtlich Performance und Sicherheit gestellt. Dies hat die Entwicklung der Sprache natürlich auch beeinflusst   -->
    	
    	Vor allem die sich derzeit in der Entwicklung befindliche Layoutenging Servo, welche in Rust geschrieben ist, hat die Sprache beeinflusst <a href="#r7">[7]</a>. <!-- (0:03:25) -->. 
    	Mit Servo versucht Mozilla eine bessere Performance im Bereich der Darstellung einer Website zu erreichen. 
    	<!--Dazu werden diese komplexen und aufwendigen Tasks auf mehrere Threads verteilt und parallel abgearbeitet. Es stellt sich hier die Frage, warum man nicht zu etablierten Sprachen wie C++ oder Java gegriffen hat. 
    	--><br>
    	Die Entwickler haben sich bei Servo bewusst gegen die Verwedung etablierter Sprachen, wie C++ oder Java entschieden. MIt C++ lässt sich realtiv einfach unsicherer Code geschrieben werden, der zu Sicherheitslücken führt. Dies hätte fatale Auswirkungen für einen Webbrowser und desen Nutzer.     	
<!--
    	
    	C++ ermöglicht es beispielsweise, mithilfe von Zeigern sehr einfach auf Speicherbereiche zu zugreifen und diese zu verändern. Geschieht dies unkontrolliert, kann es hierbei zu erheblichen Sicherheitslücken kommen, was fatale Auswirkungen für einen Webbrowser und desen Nutzer nach sich zieht.        
    	
-->
        Da bei neueren Webbrowser verstärkt Multithreading zum Einsatz kommt, muss auch hierbei besonderes auf die Sicherheit bezüglich des Speicherzugriffs geachtet werden. Dies kann mit C++ realisiert werden, erfordert aber erfahrene Programmierer und ist meist sehr aufwändig <a href="#r6">[6]</a>. <!-- (0:03:45 - 0:04:40) -->
       	
    	Die Sprache Java auf der anderen Seite bietet mit einer Runtime und einem Garbage Collector eine relative Sicherheit bezüglich des Speicherzugriffs. Bestimmte Speicherzugriffsfehler können damit verhindert werden. Trotzdem können auch damit, Fehler wie Data Races bei der parallelen Programmierung oder Iterator Invalidation nicht verhindert werden. <a href="#r8">[8]</a> <!-- (0:09:45) --><br>
    	
    	<!-- stich wort interupt Excception um eine Thread abzubrechen-->
    	Mit Rust haben die Entwickler versucht, eine Sprache zu schaffen, die sicherheit bietet und gleichzeitig komfortable zu benutzen ist. Wie dies Umgesetzt wird und wie man Rust im Bereich Web verwendent kann soll in den folgenden Kapiteln behandelt werden.
       	</p>
	</section>
	<section id="sec2">
    	<h2>2. Ziel von Rust</h2>
    	<p> Rust als Programmiersprache kann mit &bdquo;Safe Systems Programming&ldquo; beschrieben werden. Rust ist eine Programmiersprache zur systemnahen Programmierung, die sich am ehesten mit C++ oder Haskell vergleichen lässt. Rust vereint somit Funktionalitäten von imperativen und funktionalen Programmiersprachen <a href="#r7">[7]</a>. <!-- (0:01:15) -->.
    	Im folgenden werden die wichtigsten Anforderungen, die die Entwickler an die Sprache gestellt haben kurz erläutert.
    	</p>
    	<h4> Performance </h4>
    	<p>
			 C++ ist für Rust in Sachen Performance der Maßstab, da alle modernen Browser in C++ geschrieben sind <a href="#r6">[6]</a>. <!-- (0:03:50) -->
			 
<!--
			 That said, it is an explicit goal of Rust to be as fast as C++ for most things. Language decisions are made with performance in mind, and we want Rust to be as fast as possible.
-->
			 Dies bedeutet, dass Rust für viele Bereiche genau so schnell sein sollen, wie C++. Die Performance wurde daher bei der Entwicklung der Sprache immer mit berücksichtigt <a href="#r3">[3]</a>. 
			 <!--Gerade bei Webbrowsern spielt die Performance eine große Rolle.
			 , da schon eine kleiner Verzögerungen bei der Darstellung von Websites im Vergleich zur Konkurrenz wichtige Marktanteile kosten können.-->
    	</p>
    	<h4> Kontrolle </h4>
    	<p>	
			Rust soll den Programmiern im Bereich Speicherzugriff viele Freiheiten bieten. <!-- und es einfach machen, nachzuvollziehen, wie Speicher auf dem Stack und Heap reserviert wird und belegt wird. -->  Auch hier ist C++ das Vorbild. <!-- Diese Sprachen bieten die Möglichkeit Speicher direkt zu Adressieren und mit Zeigern darauf zuzugreifen.  Zitat ? -->
			In Rust, wie auch in C++, gibt es <i>Deterministic Destruction</i>, dies bedeutet, dass lokale Variablen und statisch angeforderter Speicher am Ende eines Blocks automatisch freigegeben werden. <!-- TODO bezug auf Ownership -->
			<!-- TODO Deterministic Destruction in c++ nachlesen -->
			Somit ist den Programmierern bekannt, wann Speicher wieder freigeben wird. 
			In Rust gibt es keine <i>Garabage Collection</i>, da  die Runtime möglichst klein gehalten werden sollte und damit auch nicht sicher fest steht, wann Speicher freigegeben wird <a href="#r7">[7]</a>. <!-- (0:05:25) -->. 
			<!--
			Wie auch bei C++ soll es möglich sein Speicher direkt zu adressieren und auf diesen Zuzugreifen. Auch soll
			der Programmierer entscheidet, wann Speicher alloziert und freigegeben wird. Somit soll Rust nur mit einer möglichst minimalen Runtime und keinem Garbage Collector auskommen. 
			-->	
    	</p>
    	<h4> Sicherheit </h4>
    	<p>
			<!-- TODO Ziate -->
			 Rust soll sicher sein. Sicherheit bezieht sich hierbei auf den Speicherzugriff. Die Programmierer sollen die Möglichkeit haben möglichst systemnah zu programmieren, trotzdem sollen dafür bestimmte Regeln gelten, welche vor Fehlern, wie bspw. <i>Use After Free</i>, <i>Dangling Pointers</i> oder <i>Iterator Invalidation</i> schützen. 
<!--
			 Bei Use After Free wird auf Speicher zugegriffen (bspw. mit einem Zeiger, der auf diesen zeigt), der zuvor freigeben wurde. Ein solcher Zeiger wird auch Dangling Pointer genannt. Mit Rust soll dies nicht mehr möglich sein. Auch Iterator Invalidation soll verhindert werden. Hierbei wird ein sogenannter <i>Container</i> (in C++ bspw. vector&lt;T&gt;) mittels eines Iterators durchlaufen. Dabei kommt es dazu, dass dieser seine Form ändert (bspw. wird ein Element hinzugefügt) und Speicher im Heap muss realloziert werden. Somit ist der Iterator nicht mehr gültig. Auch dieser Fehlerfall soll mit Rust nicht möglich sein. 			 
-->
			 Besonders im Bereich parallele Programmierung kann es sehr schwer und Umständlich werden, die Speicherzugriffe aller Threads im Blick zu haben, um mögliche Fehler auszuschließen.
			 Auch hier soll Rust mehr Sicherheit bieten, als etabliert systemnahe Sprachen. Als Beispiel für einen häufig auftretenden Fehler sei hier <i>Data Races</i> angeführt. 			 
<!--
			 Dabei greifen zwei oder mehr Threads auf einen Speicherbereich zu, wobei mindestens einer von ihnen schreibt und die Threads nicht synchronisiert sind.
-->
			 Mit welchem Konzepten Rust diese Fehler verhindert soll im nächsten Kapitel näher beschrieben.
    	</p>
    	<h4> Parallelität </h4>
    	<p>
			Die meiste, der derzeit Verwendeten Hardware besitzt zwei oder mehr Prozessoren. Auch mit Rust soll es daher möglich sein diese sinnvoll zu nutzen. Hier hat das Servo Projekt die Sprache stark beeinflusst. 
			Die Sprache selbst enthält dabei allerdings keine Konstrukte für Multithreading, diese wird durch eine Standard Bibliothek angeboten, was wiederum die Möglichkeit beietet andere Konzepte der parallelen Programmierung zu nutzen, als die von den Entwicklern von Rust vorgesehen.	<!-- TODO Zitat -->	
				 
    	</p>
    	<h4> Features höherer und funktionaler Programmiersprachen</h4>
    	<p>
			Bei der Entwicklung von Rust, wurden auch Funtkionalitäten höher und funktionaler Programmiersprachen mit in die Sprache genommen.			
			Diese ermögliche es Programmierern sehr komfortabel und schnell Programme zu schreiben. 
			Rust ist keine Objektorientiert oder rein funktionale Programmiersprache, sondern es wurde 
			vielmehr auf einen Multiparadigmen Ansatz gesetzt. <!-- TODO Zitat -->
    	</p>

    </section>
    <section id="sec3">
		<h2>3. Ownership and Borrowing </h2>
		<p>
		 Ownership and Borrowing ist eines der wichtigstes Konzepte der Sprache und ist der Hauptunterschied zu allen etablierten Sprachen <!-- TODO Ziat -->. Mit diesem Konzept erreicht Rust die Sicherheit und Schnelligkeit.
		 Dabei wird die Einhaltung dieser, auf den ersten Blick sehr streng erscheinenden Regeln, beim kompilieren überprüft. Dies bedeutet, dass Fehler, die diese Regeln verletzen, nicht erst zur Laufzeit erkannt werden <a href="#r1">[1]</a>. <!-- /ownership.html --> 
		</p>
		
		<h3>3.1 Ownership</h3>
		<p>Unter Ownership versteht man, dass eine Ressource zu einem Zeitpunkt genau einen Besitzer hat. Eine Ressource kann dabei eine Zahl, im weitesten Sinne ein Objekt oder auch eine Datei sein <a href="#r7">[7]</a>.  Im Allgemeinen kann man bei einer Ressource von einem reservierten Speicherbereich sprechen, der im laufe des Programms verwendet werden soll. Solch ein Speicherbereich wird meist an einen Bezeichner bzw. Variable gebunden.				
		Jede Variable hat damit eine zusätzliches Attribut, ihren Besitzer. Wird der Gültigkeitsbereich des Besitzers der Variable im Programmverlauf verlassen, so wird die Variable und der allozierte Speicher auf dem Stack und auf dem Heap gelöscht. Dies wird immer am Ende eines Gültigkeitsbereiches ausgeführt, man spricht daher auch von Deterministic Destruction <a href="#r1">[1]</a>.		
		Ownership, also der Besitz an einem Speicherbereich, kann auch übertragen werden. Damit wird die Ressource an eine andere Variable gebunden. Am folgenden Beispiel soll dies verdeutlicht werden.		
		<!-- Falls am Ende noch Platz ;) -->
		<!-- In <a href="#r1">[1]</a> wird diese am Besipiel eines Vektors verdeutlicht. Wird ein solcher angelegt, so wird für diesen Speicher auf dem Stack reserviert. Hier befindet sich das Vektor Objekt, also Daten, wie bspw. Länge Kapazität und ein Zeiger in den Heap. Auf dem Heap werden die eigentlichen Elemente des Vektors gespeichert. Wird der der Besitz an diesem Vektor übertragen, so werden nur die Daten des Stacks kopiert und an eine neue Variable gebunden. Die Daten auf dem Heap bleiben unverändert. Da es nun theoretisch zwei Zeiger auf  die Daten im Heap existieren, wird die Nutzung des alten Zeigers verboten. Je nach grad der Optimierung, können die alten daten auf dem Stack auch schon gelöscht wurden sein. -->	
		</p>			
		<figure id="li1"> 
<pre>
fn foo() {
  // anlegen eines leeren Vektors für Integerwerte
  let mut y: Vec&lt;i32&gt; = Vec::new();		
  
  y.push(4);  //den Wert '4' zum Vektor hinzufügen
  
  bar(y);  //der Funktion 'bar' den Vektor übergeben
           //-> Besitz wird übertragen 
           
  y.push(5); // Compiler Error	
}</pre>

<pre>
fn bar(x: Vec&lt;i32&gt;) {	
  ...
  //der übergebene Vektor kann wie eine 
  //lokale Variable behandelt werden
  
  //am Ende der Funktion wird 'x' gelöscht und der Speicher freigegeben
}</pre>
		<figcaption>
            <strong>Listing 1</strong>: Übertragung von Ownership an eine Funktion.</a>
        </figcaption>
        </figure>
        <p>
		Das oben stehende Beispiel zeigt das anlegen eines Vektors, deren Besitzer die Funktion <code>foo</code> ist. Es wird der Wert 4 zum Vektor hinzugefügt und anschließend dieser, der Funktion <code>bar</code> übergeben. Die Funktion <code>bar</code> ist jetzt der neue Besitzer des Vektors und kann die Werte lesen, löschen und zu diesem hinzufügen. Da diese Funktion keinen Rückgabewert besitzt, wird bei Funktionsende der Vektor gelöscht, da er keinen Besitzer mehr hat. In der Funktion <code>foo</code> wird nach dem Aufruf von <code>bar</code> versucht auf den Vektor zuzugreifen, was zu einem Compiler Fehler führt, da <code>foo</code> nicht mehr Besitzer des Vektors ist. Weiterhin ist dieser bereits gelöscht, was zu einem <i>Use After Free</i> führen würde. 
        </p>
        		
		<h3>3.2 Boworring</h3>
		<p>In Rust ist es ebenfalls möglich Speicher zu referenzieren. Man spricht hierbei von Borrowing, da der Besitzt an einer Ressource verliehen bzw. geborgt werden kann. Verlässt eine Variable, die den Besitz an einer Ressource nur geborgt hat, ihren Gültigkeitsbereich, so wird der Speicher für die die Ressource nicht freigeben <a href="#r1">[1]</a>. <!-- /references-and-borrowing.html -->. 		
		Es werden zwei Arten Borrowing unterschieden.
		</p>
		<h4>3.2.1 Shared Borrow</h4>
		<p>
			Beim Shared Borrow, kann der Besitzer dieser Referenz die Ressource nicht verändern, allerdings können mehrere Referenzen auf eine Ressource existieren. (Auch der Besitzer der Ressource selbst kann diese nicht verändern, solange Referenzen auf diese existieren.) Man spricht hier auch von Aliasing. Hierbei wird der Referenz nur lesender Zugriff auf die Ressource gewährt, da andere existierende Referenzen keine Informationen darüber erhalten würden, falls sich die Ressource verändert. <!-- TODO Zitat -->
			Das nachfolgende Beispiel verdeutlicht dies.			
			<!-- Bsp. für Iterator Invalidation einfügen, falls noch Platz -->
			<!-- Beispielsweise könnte bei einem Array ein Element hinzugefühgt werden, was evtl. da zu führen würde, das auf dem Heap an der aktuellen position nicht genügend Speicherplatz vorhanden ist. Der Vektor würde dann an eine andere Stelle mit ausreichend Speicherplatz (falls vorhanden) verschoben. Damit müssten <strong>alle</strong> anderen Referenzen aktuallieisert werden, um ungültigen Speicherzugriff zu verhindern. Dieses verhalten wird daher beim Shared Borrow verboten. -->
		</p>
		<figure id="li2"> 
<pre>
fn foo() {
  // anlegen eines leeren Vektors für Integerwerte
  let mut y: Vec&lt;i32&gt; = Vec::new();		
  
  y.push(4);  //den Wert '4' zum Vektor hinzufügen
  
  bar(&y);  //der Funktion bar eine unveränderliche Referenz 
            //auf den Vektor übergeben 
           
  y.push(5); // Ok
}</pre>

<pre>
fn bar(x: &Vec&lt;i32&gt;){
  ...	
  b = a + x[0];  // lesender Zugriff ist erlaubt
	
  x.push(1); // Compiler Error
}</pre>
		<figcaption>
            <strong>Listing 2</strong>: Beispiel Shared Borrow.</a>
        </figcaption>
        </figure>
		<p>
			Wie auch in <a href="#li1">Listing 1</a> wir in der Funktion <code>foo</code> ein Vektor angelegt. Hier wird jedoch nur eine unveränderliche Referenz, gekennzeichnet durch das <code>&</code>, der Funktion <code>bar</code> übergeben. Diese kann somit lesend auf den Vektor zugreifen. Schreibender Zugriff ist nicht möglich und führt zu einem Compiler Fehler. Wird <code>bar</code> fehlerfrei beendet, so ist die <code>foo</code> weiterhin Besitzer des Vektors. Existieren keine weiteren Referenzen auf diesen, so kann der Vektor auch verändert oder gelöscht werden.  
		</p>
		
		<h4>3.2.2 Mutable Borrow</h4>
		<p>
			Bei Mutable Borrow darf nur eine aktive Referenz auf eine Ressource existieren und der Besitzer dieser Referenz darf die Ressource verändern. Hier wird die Veränderung erlaubt, aber Aliasing verboten.
			Weiterhin dürfen Shared und Mutable Borrow nie gemeinsam auftreten und eine Referenz darf nie länger existieren als der ursprüngliche Besitzer der Ressource. <!-- TODO Zitat -->
			Auch dies soll wieder an einem Beispiel verdeutlicht werden.
		</p>
		<figure id="li3"> 
<pre>
fn foo() {	
  // anlegen eines Vektors für Integerwerte 
  // mit initialen Werten von 1 bis 5
  let mut y: Vec&lt;i32&gt; = vec![1,2,3,4,5];
  
  // anlegen eines leeren Vektors für Integerwerte
  let mut x: Vec&lt;i32&gt; = Vec::new();
		
  bar(&y, &mut x); // Ok
  bar(&y, &mut y); // Compiler Error
}</pre>

<pre>
fn bar(y: &Vec&lt;i32&gt;, x: &mut Vec&lt;i32&gt;){
  // diese Funktion kopiert die Werte des ersten übergebenen Vektors 
  // an das Ende des zweiten
  
  for val in y{
    x.push(*val);
  }
  
}</pre>
		<figcaption>
            <strong>Listing 3</strong>: Beispiel Mutable Borrow.</a>
        </figcaption>
        </figure>
        <p>
			In diesem Beispiel werden in der Funktion <code>foo</code> zwei Vektoren angelegt. Der erste wird mit den Werten von 1 bis 5 initialisiert. Die Funktion <code>bar</code> bekommt beide Vektoren als Referenzen übergeben. Dabei wird <code>y</code> als Shared Borrow und <code>x</code> als Mutable Borrow übergeben. <code>bar</code> kopiert dann den Inhalt des ersten Vektors ans Ende des zweiten. Auf den ersten wird also nur lesend zugegriffen, während der zweite verändert wird. In der letzten Zeile, wird <code>y</code> zweimal übergeben, einmal als Shared Borrow und einmal als Mutable Borrow. Dies führt zu einem Compiler Fehler, da es Rust nicht gestattet, das auf eine Ressource zwei Referenzen existieren, wobei eine diese verändern kann. Somit werden mögliche Data Races schon beim kompilieren verhindert.
        </p>    
    </section>
    
    
    <section id="sec4">
		<h2>4. Vor- und Nachteile von Rust</h2>
		<p>Im folgenden sollen die Vor- und Nachteile der Sprache, die in den vorhergehenden Abschnitten schon angesprochen wurden zusammen gefasst werden.
		</p>
		
		<h3>4.1 Vorteile</h3>
		<p> 
			Ein großer Vorteil von Rust ist, dass viele Fehler, die den Speicherzugriff betreffen schon beim Kompilieren erkannt werden können. Erreicht wird dies, durch das in <a href="#sec3">Kapitel 3</a> vorgestellte Konzept Ownership und Borrowing. Damit ermöglicht Rust sichere systemnahe Programmierung. Die Anwendung dieses Konzepts für die parallele Programmierung, vereinfacht es auch hier, Fehler zu vermeiden, die leicht mit andern Sprachen auftretet.  <br>
			Rust eignet sich auch sehr gut für Programmieranfänger. Der Compiler liefert aussagekräftige Fehlerbeschreibungen, die mit Hilfe von Fehlercodes noch detaillierter und teilweise mit Beispielen noch genauer erklärt werden.<br>		
			Auch die Features von Funktionalen Programmiersprachen die in Rust enthalten sind machen es sehr komfortable mit Rust zu programmieren.						
			Als Beispiele für diese seine hier <i>Pattern Matching</i>, <i>Traits</i> und <i>Closures</i> genannt.						
			Patern Matching wird in Rust bspw. bei der Auswertung von Bedingungen eingesetzt. Wo in C++ komplizierte if/else Konstrukte nötig sind, kann dies in Rust meist elegant mit Pattern Matching realisiert werden <a href="#r1">[1]</a>. <!--/match.html-->			
			Traits ähneln sehr Interfaces in Sparchen, wie C++ oder Java. In der funktionalen Programmiersprache Haskell kann man sie mit den Type Classes vergleichen <a href="#r9">[9]</a>. 		
			Sie bieten die Möglichkeit eine Sammlung von Funktionen zu deklarieren, die für ein Datentypen implementiert werden können <a href="#r1">[1]</a>.  Somit lassen sich Klassen ähnliche Strukturen in Rust definieren. Traits finden sich auch Programmiersprachen, wie PHP oder Perl.		
			Eine genauerer Gegenüberstellung von Rust und funktionalen Programmiersprachen findet sich in <a href="#r9">[9]</a>. <br>
			<!-- evtl. noch FFI -->
			Mit der Sprache selbst, kann auch <i>Cargo</i> installiert werden. 
			Cargo ist ein Werkzeug, das sich hauptsächlich um die Abhängigkeiten und das erstellen der Anwendung kümmert. Dazu lädt Cargo die benötigten Abhängigkeiten für ein Rustprojekt herunter und erstellt dieses, in dem es den Compiler mit den benötigten Parametern aufruft <a href="#r10">[10]</a>. 
			 <!--evtl. noch das mit der .toml konfig datei rein-->
			Mittels Cargo lassen sich auch die Open Source Projekte von crates.io herunterladen und für eigene Anwendungen nutzen. Unter  http://crates.io befindet sich das offizielle Repository für mit Rust geschriebene Bibliotheken (ca. 3.700 Stück, Stand Januar 2016 <a href="#r10">[10]</a> <!-- TODO richtige Quelle angeben! -->). <br>
			Eine wichtige Aufgabe bei der Softwareentwicklung ist die Dokumentation. Auch dafür bringt Rust eine nützliches Werkzeug mit. Mit <i>rustdoc</i> lässt sich eine Dokumentation in HTML  aus dem Quelltext erstellen. Ähnlich, wie mit dem für Java bekannte javadoc. 
			
<!--
			Dazu werden Kommentare in Markdown (einer einfachen Auszeichnungssprache) im Quellcode angegeben oder in einer extra Datei geschrieben  <a href="#r1">[1]</a> <!--/documentation.html-->.  <!-- TODO javadoc --> 
			<!-- Die Dokumentation lässt sich ebenfalls mit Cargo erstellen.
-->
			<br>
			Rust ist somit ein ... <!--TODO Schlussatz-->
		 </p>
		 <h3>4.2 Nachteile</h3>
		 <p>
			 <!-- TODO ausformulieren -->
			 - sehr jung
			 -> häufige Änderungen -> Optimierung: Standartbibio, Compiler, Cargo 
				-> quelle: Blog
				-> gerade vor der Version 1.0 sehr oft
				-> jetzt comitmment zur Stabilität
			 - Biblotheken auf crates.io sind Opensource
				-> Doku ist daher manchmal nicht ganz vollstädig
						-> ist kein Nachteil der Sprache selbst
			- lernkurve 	
				- bsp. Ownership and Borrowing, Strings, 
				-> das muss man bei jeder anderen Sprache auch tun
		 
			 
			 Die hier angegeben Nachteile ergeben sich meist dadurch, dass Rust noch eine sehr junge Sprache ist. Rust befindet sich immer noch in der Entwicklung und unterliegt noch vielen Veränderungen. <!--Auch wenn man sich mit der Version 1.0  zur Stabilität der Sprache verpflichtet hat, so gibt es noch viele Änderungen.--> <!-- TODO Zitat und Quelle -->
			 Diese betreffen vor allem die Standardbibliothek und den Compiler, und gelten meist der Optimierung.  Für den Einsatz in einem produktiven Umfeld <!-- ? --> eignet sich die Sprache daher aber noch nicht.
			 <!-- TODO ergänzen: Doku, kompilierzeit-->			 
		 </p>
    </section>
    <section id="sec5">
		<h2>5. Rust in the Web</h2>
		<p>
			Da bei Rust Sicherheit und Performance im Vordergrund setehen, eignet sich die Sprache besonders für die Entwicklung von Webanwendungen. Auf crates.io finden sich dazu bereits viele bestehende Bibliotheken, die für eigenen Projekte genutzt werden können. Eine Auswahl soll in diesem Kapitel kurz vorgestellt werden.
			<br>
			Die Möglichkeit einen Server zu programmieren bieten zum Beispiel <i>Hyper</i> und <i>tiny-http</i>. Hyper ist eine in Rust geschriebene HTTP Implementation, die eine typsichere Abstraktion dieses Protokolls bietet. Mit Hyper lassen sich sowohl 
			ein HTTP Server als auch ein HTTP oder HTTPS Client erstellen <a href="#r11">[11]</a>.
			Mit tiny-http ist es ebenfalls möglich einen HTTP-Server zu erstellen. Bei der Entwicklung von tiny-http wurde viel Wert auf Geschwindigkeit gelegt und bei der Abarbeitung der Anfragen kommt Multithreading zum Einsatz <a href="#r12">[12]</a>.	
			<i>Curl-Rust</i> ist eine Anbindung an die weit verbreitete <i>libcurl</i> Bibliothek für Rust <a href="#r13">[13]</a>. Diese in C geschriebene Bibliothek, wird zur clientseitigen Dateiübertragung eingesetzt und unterstützt dazu Protokolle, wie bspw. HTTP, HTTPS, IMAP, POP3, FTP, Telent <a href="#r14">[14]</a>. <br>
			Der zugriff auf Datenbanken ist eine häufige Anforderung an eine Webanwendungen. Für Rust gibt es dazu beispeilsweise die Bibliotheken <i>Rust-Postgres</i>, <i>Rusqlite</i> und <i>redis-rs</i>.
			Rust-Postgres kann verwendet werden, wenn eine PostgreSQL Datenbanken genutztwerden soll <a href="#r15">[15]</a>. Für SQLite Datenbanken eigenet sich die Bibliothek Rusqlite <a href="#r16">[16]</a>.	Mit redis-rs lassen sich Clients erstellen, um auf <i>Redis</i> Datenbanken zuzugreifen <a href="#r17">[17]</a>. Redis ist eine  In-Memory-Datenbank mit einem Key-Value Datenmodell <a href="#r18">[18]</a>.<br>
<!--
			, wobei viele verschiedenen Arten von Werten unterstützt werden, wie bspw.: Zeichenketten, Listen, Hashes oder auch Bitmaps  
-->
			Um das Entwickeln einer Webanwendung zu vereinfachen werden meist Webframeworks verwendet. Für Rust gibt es unter andderem die Frameworks <i>Rustful</i>, <i>nickel.rs</i> und <i>Iron</i>.			 
			Rustful ist ein Framework, mit dem Ziel eine einfache und modular aufgebaute Grundlage zu bieten, um HTTP Anwendungen zu programmieren. Rustful eignet sich vor allem, um Anwendungen mit REST APIs zu erstellen <a href="#r20">[20]</a>. 
			Ein weiteres Framework, was zur Erstellung einer Webanwendung genutzt werden kann ist nickel.rs, welches durch das Express Framework für JavaScript inspiriert wurde <a href="#r21">[21]</a>. Das Serverframework <i>Iron</i> soll im nächsetn Kapitel genauer Vorgestellt werden und kommt auch in der Demo zum Einsatz.
		</p>
    </section>
    <section id="sec6">
		<h2>6. Iron</h2>
		<p>
			<!-- TODO Quellen angeben ! -->
			
<!--
			Iron is a fast and flexible middleware-oriented server framework that provides a small but robust foundation for creating complex applications and RESTful APIs. No middleware are bundled with Iron - instead, everything is drag-and-drop, allowing for ridiculously modular setups. <a href="#r19">[19]</a>
-->
			Iron ist ein schnelles unf flexibeles Serverframework, welches mudular aufgebaut ist und mit dem sich komplexe Anwendungen erstellen lassen <a href="#r19">[19]</a>.			
			Iron ist in Rust geschriebenes und basiert auf Hyper (siehe <a href="#sec5">Kapitel 5</a>).	
			Es kann auf einem Rechner mit einem oder mehreren Threads genutzt werden oder auf mehreren Rechnern verteilt zum Einsatz kommen.
			Das Grundframework ist dabei nicht durch unötige Funktionalität überladen, sondern lässt sich für eigene Anwendung, mit <i>Middleware</i>, <i>Plugins</i> oder <i>Modifiers</i> erweitertn.	Middleware kann für Routing, Mounting, Authentifizierung  oder Logging eingesetzt werden. Plugings und Modifierer eignen sich, um auf eine  HTTP-Verbindung zuzugreifen oder diese zu Manipulieren. Iron bietet die Grundlage, selbst Modifier, Plugins und Middleware zu erstellen oder man kann esxisitierende nutzen, um Satus, Body und verschiedene Header zu setzen <a href="#r22">[22]</a>.<br>
			
			Iron ermöglicht es auch, eine in die URL eines GET Requests codierte Anfragen zu verarbeiten. Dazu kann die Middleware <i>urlencoded</i> genutzt werden, welche die angegeben Parameter, nach dem parsen als Key Value Paare zur Verfügung stellt <a href="#r23">[23]</a>.
			
			
			Kommt ein POST Request beim Server an, so wird der Body, falls vorhanden, mit dem <i>body-parser</i> Plugin in ein Struct geparsed, welches dann weiter verarbeitet wird <a href="#r24">[24]</a>.
				
			
			Das Webframework wurde in der nachfolgend beschriebenen Demo, zum erstellen eines einfachen Webservers eingesetzt. 	Auf einige weitere Funktionalitäten, die Iron bietet wird dort nochmal näher eingegangen.			
		</p>
    </section>
    <section id="sec7">
		<h2> 7. Demo </h2>
		Um die Funktionsweise von Iron zu demonstrieren wurde eine einfache Client-Server-Anwendung erstellt. Mit dieser soll zwei, vom Benutzer eingegebene Matrizen an den Server übermittelt werden und von diesem, falls möglich, addiert und multipliziert werden. Das Ergebnis dieser Berechnung oder evtl. auftretende Fehler, werden dann dem Benutzer angezeigt.		
		Der gesamte Quellcode kann unter <a href="https://github.com/ekunTUC/rust-matrix-rechner">https://github.com/ekunTUC/rust-matrix-rechner</a> eingesehen und heruntergeladen werden. 
		Die folgende Abbildung zeigt eine Übersicht über die erstellte Demo.
		<p>
		<figure>
          <img src="uebersicht.jpg" alt="Übersicht"/>
          <figcaption>
            <strong>Abbildung 1</strong> Vereinfachte Übersicht der Client-Server-Anwendung.
          </figcaption>
        </figure>
		</p>
		<p>
		<h4> Client</h4>
		Der Client ist eine Website, in welcher der Benutzer zwei Matrizen eingeben kann. Diese wird vom Server mit allen zusätzlich benötigten Dateien, wie Scripten und Bildern vom Server geladen. Der Benutzer kann dann selbst zwei Matrizen eingeben oder diese randomisiert über das links stehenden Menü erstellen. Klickt der Nutzer auf <i>Berechnen</i>, so wird mittels JavaScript die  Eingabe auf grobe Fehler, wie beispielsweise leere Matrix, Verwendung von Buchstaben oder Fließkommazahlen überprüft und diese dem Benutzer angezeigt. Ist die Eingabe fehlerfrei, so werden beide Matrizen an den Server, mittels POST Request, übermittelt. Die benötigten Daten werden dabei in JSON codiert und in den Body des Requests geschrieben.
		Der Server führt die Berechnungen aus und liefert das Ergebnis ebenfalls als JSON im Body der Response zurück. Diese wird wiederum mittels JavaScript geparsed und dem Benutzer werden die Ergenisse angezeigt.			
		</p>
		<p>
		<h4>Server</h4>
		Das folgende Bild zeigt schematisch, die Arbeitsweise des erstellten Servers.
		<p>
		<figure>
          <img src="iron_server.jpg" alt="Iron Server"/>
          <figcaption>
            <strong>Abbildung 2</strong>: Vereinfachtes AKtivitätsdiagramm des Servers.
          </figcaption>
        </figure>
		</p>
		Nach dem Start des Servers, wartet dieser auf einen eingehenden Request. 
		Als Vereinfachung wird bei einem GET Request versucht, die angegebenen zu laden und als Response zurück zu senden. Kommt es hier zu einem Fehler, wird ein entsprechender HTTP Fehlercode als Response gesendet. <br>
		Kommt ein POST Request beim Server an, so wird der Body, falls vorhanden, mit dem <i>body-parser</i> Plugin in ein Struct geparsed, welches dann weiter verarbeitet wird <a href="#r24">[24]</a>. 
		Falles es hier zu einem Fehler kommt, wird ebenfalls eine Response mit entsprechendem Fehlercode gesendet.<br>
		Im nächsten Schritt werden zwei Threads gestartet. Der erste Thread soll die übergebenen Matrizen Addieren. Ist dies, wegen unterscheidlicher Größe nicht möglich, so liefert der Thread 
		<code>None</code> zurück. Hierbei, wir der von Rust bereitgestellte Datentyp <code>Option&lt;T&gt;</code> genutzt, der es ermöglich, das eine Funktion einem Rückgabewert hat oder nicht <a href="#r1">[1]</a> <!--/error-handling.html-->.
		Die Multiplikation läuft simultan in einem zweiten Thread ab und liefert analog, das Ergebnis bzw. <code>None</code>, je nach dem, ob die Berechnung möglich war.<br>
		Sind beide Threads beendet, so werden die Ergebnisse mit Hilfe von Pattern Matching ausgewertet und die entsprechende Response mit etwaigen Fehlermeldungen erstellt und zum Client gesendet.<br>
		Der Server wartet im Anschluss auf den nächsten Request.
		</p>		
    </section>
    
    <section id="sec8">
		<h2>8. Fazit</h2>
		<p>
			
		</p>
    </section>

	<section class="references" id="sec9">
	   		<h2>9. Literaturverzeichnis</h2>
	   		
	   		<p class="reference" id="r1">[1] The Rust Programming Language [Online]. <br> Available: <a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a> (21.12.2015)</p>
	   		
	   		<p class="reference" id="r2">[2] The Rust Design FAQ [Online]. <br>  Available: <a href="https://doc.rust-lang.org/stable/complement-design-faq.html">https://doc.rust-lang.org/stable/complement-design-faq.html</a> (21.12.2015)</p>
	   		
	   		<p class="reference" id="r3">[3] The Rust Language FAQ [Online]. <br>  Available: <a href="https://doc.rust-lang.org/stable/complement-lang-faq.html">https://doc.rust-lang.org/stable/complement-lang-faq.html</a> (21.12.2015)</p>
	   		
	   		<p class="reference" id="r4">[4] The Rust Project FAQ [Online]. <br>  Available: <a href="https://doc.rust-lang.org/stable/complement-project-faq.html">https://doc.rust-lang.org/stable/complement-project-faq.html</a> (21.12.2015)</p>
	   		
	   		<p class="reference" id="r5">[5] The Rust Core Team (2015, May 15) The Rust Programming Language Blog, Announcing Rust 1.0  [Online]. <br>  Available: <a href="http://blog.rust-lang.org/2015/05/15/Rust-1.0.html">http://blog.rust-lang.org/2015/05/15/Rust-1.0.html</a> (27.12.2015)</p>
	   		
<!-- Youtube -->
			<p class="reference" id="r6">[6]  Linux.conf.au 2015 -- Auckland, New Zealand, Jack Moffitt, "Servo: Building a Parallel Browser", YouTube.com 16.01.2015 [Online]. <br>  Available: <a href="https://www.youtube.com/watch?v=O5vzLKg7y-k">https://www.youtube.com/watch?v=O5vzLKg7y-k</a> (27.12.2015)</p>

	   		<p class="reference" id="r7">[7] stanfordonline, Aaron Turon, "The Rust Programming Language", YouTube.com 12.03.2015 [Online]. <br>  Available: <a href="https://www.youtube.com/watch?v=O5vzLKg7y-k">https://www.youtube.com/watch?v=O5vzLKg7y-k</a> (27.12.2015)</p>
	   		
	   		<p class="reference" id="r8">[8] GoogleTechTalks, Alex Crichton, "The Rust Programming Language", YouTube.com 28.07.2015 [Online]. <br>  Available: <a href="https://www.youtube.com/watch?v=d1uraoHM8Gg">https://www.youtube.com/watch?v=d1uraoHM8Gg</a> (27.12.2015)</p>
<!-- Youtube -->	
	   	  		
	   		<p class="reference" id="r9">[9] Raphael ‘kena’ Poss (2014, July) Rust for functional programmers  [Online]. <br>  Available: <a href="http://science.raphael.poss.name/rust-for-functional-programmers.html">http://science.raphael.poss.name/rust-for-functional-programmers.html</a> (29.12.2015)</p>
	   		
	   		<p class="reference" id="r10">[10] Cargo Guide [Online]. <br> Available: <a href="http://doc.crates.io/guide.html">http://doc.crates.io/guide.html</a> (02.01.2016)</p>
<!--Rust in the web-->  
<!--TODO Autoren !-->
			
			<p class="reference" id="r11">[11] hyper [Online]. <br> Available: <a href="https://github.com/hyperium/hyper">https://github.com/hyperium/hyper</a> (02.01.2016)</p>
	   		
	   		<p class="reference" id="r12">[12] tiny-http [Online]. <br> Available: <a href="https://github.com/frewsxcv/tiny-http">https://github.com/frewsxcv/tiny-http</a> (02.01.2016)</p>
	   		
	   		<p class="reference" id="r13">[13] Curl-Rust [Online]. <br> Available: <a href="https://github.com/carllerche/curl-rust">https://github.com/carllerche/curl-rust</a> (02.01.2016)</p>
	   		
	   		<p class="reference" id="r14">[14] libcurl [Online]. <br> Available: <a href="http://curl.haxx.se/libcurl">http://curl.haxx.se/libcurl</a> (02.01.2016)</p>
	   		
	   		<p class="reference" id="r15">[15] Rust-Postgres  [Online]. <br> Available: <a href="http://sfackler.github.io/rust-postgres/doc/v0.10.2/postgres">http://sfackler.github.io/rust-postgres/doc/v0.10.2/postgres</a> (02.01.2016)</p>
	   		
	   		<p class="reference" id="r16">[16] Rusqlite  [Online]. <br> Available: <a href="https://github.com/jgallagher/rusqlite">https://github.com/jgallagher/rusqlite</a> (02.01.2016)</p>
	   		
	   		<p class="reference" id="r17">[17] redis-rs  [Online]. <br> Available: <a href="http://mitsuhiko.github.io/redis-rs/redis">http://mitsuhiko.github.io/redis-rs/redis</a> (02.01.2016)</p>
	   		
	   		<p class="reference" id="r18">[18] Redis [Online]. <br> Available: <a href="https://github.com/antirez/redis">https://github.com/antirez/redis</a> (02.01.2016)</p>
	   		
	   		<p class="reference" id="r19">[19] IRON - extensible web framework for rust [Online]. <br> Available: <a href="http://ironframework.io/">http://ironframework.io/</a> (02.01.2016)</p>
	   		
	   		<p class="reference" id="r20">[20] Rustful [Online]. <br> Available: <a href="https://github.com/Ogeon/rustful">https://github.com/Ogeon/rustful</a> (02.01.2016)</p>
				
			<p class="reference" id="r21">[21] nickel.rs [Online]. <br> Available: <a href="https://github.com/nickel-org/nickel.rs">https://github.com/nickel-org/nickel.rs</a> (02.01.2016)</p>	
			
			<p class="reference" id="r22">[22] Iron - Documentation [Online]. <br> Available: <a href="http://ironframework.io/doc/iron">http://ironframework.io/doc/iron</a> (03.01.2016)</p>	
			
			<p class="reference" id="r23">[23] urlencoded [Online]. <br> Available: <a href="https://github.com/iron/urlencoded">https://github.com/iron/urlencoded</a> (04.01.2016)</p>	
			
			<p class="reference" id="r24">[24] body-parser [Online]. <br> Available: <a href="https://github.com/iron/body-parser ">https://github.com/iron/body-parser </a>(04.01.2016)</p>
			
				
	   		
	   		
	   		
	   			   		
	   		
	</section>
</body>
</html>
