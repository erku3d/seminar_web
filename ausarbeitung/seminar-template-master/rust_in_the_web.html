<!DOCTYPE html>
<html>
<head>
  <title>Proseminar Web Engineering im Wintersemester 2015/16 - Rust in the Web</title>
  <link rel="stylesheet" type="text/css" href="main.css"/>
  <link href='http://fonts.googleapis.com/css?family=Source+Serif+Pro:400,600,700' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
</head>
<body>
    <header>
        <h2>Proseminar Web Engineering im Wintersemester 2015/16</h2>
		<h1>Rust in the Web</h1>
        <h2 class="author">Eric Kunze</h2>
		<h3 class="affiliation">
			Professur Verteilte und Selbstorganisierende Rechnersysteme<br/>
			Technische Universität Chemnitz<br/>
			Chemnitz, Deutschland
		</h3>
    </header>
<!--
    <section>
		<p> &nbsp;</p>
		<h2>Inhalt</h2>
		<h3><a href="#sec1">1. Einleitung</a></h3>
		<h3><a href="#sec2">2. Ziel von Rust</a></h3>
		<h3><a href="#sec3">3. Ownership and Borrowing</a></h3>
		<h3><a href="#sec4">4. Vor- und Nachteile</a></h3>
		<h3><a href="#sec5">5. Rust in the Web</a></h3>
		<h3><a href="#sec6">6. Iron</a></h3>
		<h3><a href="#sec7">7. Demo</a></h3>
		<h3><a href="#sec8">8. Fazit</a></h3>
		<h3><a href="#sec9">9. Literaturverzeichnis</a></h3>	
		<p> &nbsp;</p>
    </section>
-->
    <section id="sec1">
    	<h2>1. Einleitung</h2>
        <p>
<!--
    	 It started as a Graydon Hoare's part-time side project in 2006 and remained so for over 3 years. Mozilla got involved in 2009 once the language was mature enough to run some basic tests and demonstrate the idea. Though it is sponsored by Mozilla, Rust is developed by a diverse community of enthusiasts.
-->
		Rust wurde 2006 von Graydon Hoar entwickelt. Das Projekt wurde ab 2009 von Mozilla unterstützt, nach dem die Sprache so weit entwickelt war, dass man mit ihr einige Test durchführen und die Grundideen  demonstrieren konnte <a href="#r4">[4]</a>.Die Version 1.0 der Sprache wurde am 15.05.2015 veröffentlicht <a href="#r5">[5]</a>. 
<!--
    	Mozilla intends to use Rust as a platform for prototyping experimental browser architectures. Specifically, the hope is to develop a browser that is more amenable to parallelization than existing ones, while also being less prone to common C++ coding errors that result in security exploits. The name of that project is Servo.
-->
    	Bei Mozilla wird Rust vor allem zur Entwicklung von Prototypen neuer Webbrowserarchitekturen verwendet. Dabei soll verstärkt parallele Programmierung genutzt werden und diese sollen auch weniger anfällig für Sicherheitslücken sein, die beispielsweise in C++ durch Programmierfehler entstehen können <a href="#r4">[4]</a>.
    	
    	<!-- TODO evtl. noch einen Satz zum c++ Speichermodell -->
    	<!--An einen Webbrowser werden besondere Anforderungen hinsichtlich Performance und Sicherheit gestellt. Dies hat die Entwicklung der Sprache natürlich auch beeinflusst   -->
    	
    	Vor allem, die sich derzeit in der Entwicklung befindliche Layoutenging Servo, welche in Rust geschrieben ist, hat die Sprache beeinflusst <a href="#r7">[7]</a>. <!-- (0:03:25) --> 
    	Mit Servo versucht Mozilla eine bessere Performance im Bereich der Darstellung einer Website zu erreichen. 
    	<!--Dazu werden diese komplexen und aufwendigen Tasks auf mehrere Threads verteilt und parallel abgearbeitet. Es stellt sich hier die Frage, warum man nicht zu etablierten Sprachen wie C++ oder Java gegriffen hat. 
    	-->
    	Die Entwickler haben sich bei Servo bewusst gegen die Verwendung etablierter Sprachen, wie C++ oder Java entschieden. Mit C++ kann relativ einfach unsicherer Code geschrieben werden, der zu Sicherheitslücken führt. Dies hätte fatale Auswirkungen für einen Webbrowser und dessen Nutzer.     	
<!--
    	
    	C++ ermöglicht es beispielsweise, mithilfe von Zeigern sehr einfach auf Speicherbereiche zu zugreifen und diese zu verändern. Geschieht dies unkontrolliert, kann es hierbei zu erheblichen Sicherheitslücken kommen, was fatale Auswirkungen für einen Webbrowser und desen Nutzer nach sich zieht.        
    	
-->
        Da bei neueren Webbrowser verstärkt Multithreading zum Einsatz kommt, muss auch hierbei besonders auf die Sicherheit bezüglich des Speicherzugriffs geachtet werden. Dies kann mit C++ realisiert werden, erfordert aber erfahrene Programmierer und ist meist sehr aufwändig <a href="#r6">[6]</a>. <!-- (0:03:45 - 0:04:40) -->
       	
    	Die Sprache Java auf der anderen Seite bietet mit einer Runtime und einem Garbage Collector eine relative Sicherheit bezüglich des Speicherzugriffs. Bestimmte Speicherzugriffsfehler können damit verhindert werden. Trotzdem können auch damit, Fehler wie Data Races bei der parallelen Programmierung oder Iterator Invalidation nicht verhindert werden <a href="#r8">[8]</a>. <!-- (0:09:45) -->
    	
    	<!-- stich wort interupt Excception um eine Thread abzubrechen-->
    	Mit Rust haben die Entwickler versucht, eine Sprache zu schaffen, die Sicherheit bietet und gleichzeitig komfortable zu benutzen ist. Wie dies Umgesetzt wird und wie man Rust im Bereich Web verwendet kann soll in den folgenden Kapiteln behandelt werden.
       	</p>
	</section>
	<section id="sec2">
    	<h2>2. Ziel von Rust</h2>
    	<p> Rust als Programmiersprache kann mit &bdquo;Safe Systems Programming&ldquo; beschrieben werden. Rust ist eine Sprache zur systemnahen Programmierung, die sich am ehesten mit C++ oder Haskell vergleichen lässt. Rust vereint somit Funktionalitäten von imperativen und funktionalen Programmiersprachen <a href="#r7">[7]</a>. <!-- (0:01:15) -->
    	Im folgenden werden die wichtigsten Anforderungen, die die Entwickler an die Sprache gestellt haben, kurz erläutert.
    	</p>
    	<h4> Performance </h4>
    	<p>
			 C++ ist für Rust in Sachen Performance der Maßstab, da alle modernen Browser in C++ geschrieben sind <a href="#r6">[6]</a>. <!-- (0:03:50) -->
			 
<!--
			 That said, it is an explicit goal of Rust to be as fast as C++ for most things. Language decisions are made with performance in mind, and we want Rust to be as fast as possible.
-->
			 Dies bedeutet, dass Rust für viele Bereiche genau so schnell sein sollen, wie C++. Die Performance wurde daher bei der Entwicklung der Sprache immer mit berücksichtigt <a href="#r3">[3]</a>. 
			 <!--Gerade bei Webbrowsern spielt die Performance eine große Rolle.
			 , da schon eine kleiner Verzögerungen bei der Darstellung von Websites im Vergleich zur Konkurrenz wichtige Marktanteile kosten können.-->
    	</p>
    	<h4> Kontrolle </h4>
    	<p>	
			Rust soll im Bereich Speicherzugriff viele Freiheiten bieten und auch hier ist C++ das Vorbild. <!-- und es einfach machen, nachzuvollziehen, wie Speicher auf dem Stack und Heap reserviert wird und belegt wird. -->   <!-- Diese Sprachen bieten die Möglichkeit Speicher direkt zu Adressieren und mit Zeigern darauf zuzugreifen.  Zitat ? -->
			In Rust, wie auch in C++, gibt es Deterministic Destruction. Dies bedeutet, dass lokale Variablen und <!--statisch--> angeforderter Speicher am Ende eines Blocks automatisch freigegeben werden. <!-- TODO bezug auf Ownership -->
			<!-- TODO Deterministic Destruction in c++ nachlesen -->
			Somit ist bekannt, wann Speicher wieder freigeben wird. 
			In Rust gibt es keine Garbage Collection, da  die Runtime möglichst klein gehalten werden sollte und damit auch nicht sicher fest steht, wann Speicher freigegeben wird <a href="#r7">[7]</a>. <!-- (0:05:25) --> 
			<!--
			Wie auch bei C++ soll es möglich sein Speicher direkt zu adressieren und auf diesen Zuzugreifen. Auch soll
			der Programmierer entscheidet, wann Speicher alloziert und freigegeben wird. Somit soll Rust nur mit einer möglichst minimalen Runtime und keinem Garbage Collector auskommen. 
			-->	
    	</p>
    	<h4> Sicherheit </h4>
    	<p>
			 Rust soll sicher sein. Sicherheit bezieht sich hierbei auf den Speicherzugriff. In der Sprache sind Regeln festgelegt, die vor Fehlern, wie bspw. <i>Use After Free</i>, <i>Dangling Pointers</i> oder <i>Iterator Invalidation</i> schützen <a href="#r8">[8]</a>.  			
<!--
			 Bei Use After Free wird auf Speicher zugegriffen (bspw. mit einem Zeiger, der auf diesen zeigt), der zuvor freigeben wurde. Ein solcher Zeiger wird auch Dangling Pointer genannt. Mit Rust soll dies nicht mehr möglich sein. Auch Iterator Invalidation soll verhindert werden. Hierbei wird ein sogenannter <i>Container</i> (in C++ bspw. vector&lt;T&gt;) mittels eines Iterators durchlaufen. Dabei kommt es dazu, dass dieser seine Form ändert (bspw. wird ein Element hinzugefügt) und Speicher im Heap muss realloziert werden. Somit ist der Iterator nicht mehr gültig. Auch dieser Fehlerfall soll mit Rust nicht möglich sein. 			 
-->
			 Besonders im Bereich parallele Programmierung kann es sehr schwer und Umständlich werden, die Speicherzugriffe aller Threads im Blick zu haben, um mögliche Fehler auszuschließen.
			 Auch hier soll Rust mehr Sicherheit bieten, als etabliert systemnahe Sprachen. Als Beispiel für einen häufig auftretenden Fehler sei hier <i>Data Races</i> angeführt. 			 
<!--
			 Dabei greifen zwei oder mehr Threads auf einen Speicherbereich zu, wobei mindestens einer von ihnen schreibt und die Threads nicht synchronisiert sind.
-->
			 Mit welchem Konzept Rust diese Fehler verhindert, soll im nächsten Kapitel näher beschrieben.
    	</p>
    	<h4> Parallelität </h4>
    	<p>
			Die meiste, der derzeit verwendeten Hardware besitzt zwei oder mehr Prozessoren. Auch mit Rust soll es daher möglich sein, diese sinnvoll zu nutzen. Hier hat das Servo Projekt die Sprache stark beeinflusst. 
			Die Sprache selbst enthält dabei allerdings keine Konstrukte für Multithreading, diese wird durch eine Standard Bibliothek angeboten, was wiederum die Möglichkeit bietet, andere Konzepte der parallelen Programmierung zu nutzen, als die von den Entwicklern von Rust vorgesehenen <a href="#r1">[1]</a> <!--/concurrency.html-->.	
				 
    	</p>
    	<h4> Features höherer und funktionaler Programmiersprachen</h4>
    	<p>
			Bei der Entwicklung von Rust, wurden auch Funktionalitäten höher und funktionaler Programmiersprachen mit in die Sprache aufgenommen.			
			Diese ermöglicht es sehr komfortabel und schnell Anwendungen zu schreiben. 
			Rust ist keine objektorientiert oder rein funktionale Programmiersprache, sondern es wurde 
			vielmehr auf einen Multiparadigmen Ansatz gesetzt. 
		</p>

    </section>
    <section id="sec3">
		<h2>3. Ownership and Borrowing </h2>
		<p>
		 Ownership and Borrowing ist eines der wichtigstes Konzepte der Sprache und ist der Hauptunterschied zu allen etablierten Sprachen <!-- TODO Ziat -->. Mit diesem Konzept erreicht Rust die Sicherheit und Schnelligkeit.
		 Dabei wird die Einhaltung dieser, auf den ersten Blick sehr streng erscheinenden Regeln, beim kompilieren überprüft. Dies bedeutet, dass Fehler, die diese Regeln verletzen, nicht erst zur Laufzeit erkannt werden <a href="#r1">[1]</a>. <!-- /ownership.html --> 
		</p>
		
		<h3>3.1 Ownership</h3>
		<p>Unter Ownership versteht man, dass eine Ressource zu einem Zeitpunkt genau einen Besitzer hat. Eine Ressource kann dabei eine Zahl, im weitesten Sinne ein Objekt oder auch eine Datei sein <a href="#r7">[7]</a>.  Im Allgemeinen kann man bei einer Ressource von einem reservierten Speicherbereich sprechen, der im Laufe des Programms verwendet werden soll. Solch ein Speicherbereich wird meist an einen Bezeichner bzw. eine Variable gebunden.				
		Jede Variable hat damit eine zusätzliches Attribut, ihren Besitzer. Wird der Gültigkeitsbereich des Besitzers der Variable im Programmverlauf verlassen, so wird die Variable und der allozierte Speicher auf dem Stack und auf dem Heap gelöscht, man spricht daher auch von Deterministic Destruction <a href="#r1">[1]</a>.		
		Ownership kann auch übertragen werden. Damit wird die Ressource an eine andere Variable gebunden. Am folgenden Beispiel soll dies verdeutlicht werden.		
		<!-- Falls am Ende noch Platz ;) -->
		<!-- In <a href="#r1">[1]</a> wird diese am Besipiel eines Vektors verdeutlicht. Wird ein solcher angelegt, so wird für diesen Speicher auf dem Stack reserviert. Hier befindet sich das Vektor Objekt, also Daten, wie bspw. Länge Kapazität und ein Zeiger in den Heap. Auf dem Heap werden die eigentlichen Elemente des Vektors gespeichert. Wird der der Besitz an diesem Vektor übertragen, so werden nur die Daten des Stacks kopiert und an eine neue Variable gebunden. Die Daten auf dem Heap bleiben unverändert. Da es nun theoretisch zwei Zeiger auf  die Daten im Heap existieren, wird die Nutzung des alten Zeigers verboten. Je nach grad der Optimierung, können die alten daten auf dem Stack auch schon gelöscht wurden sein. -->	
		</p>			
		<figure id="li1"> 
<pre>
fn foo() {
  // anlegen eines leeren Vektors für Integer-Werte
  let mut y: Vec&lt;i32&gt; = Vec::new();		
  
  y.push(4);  //den Wert 4 zum Vektor hinzufügen
  
  bar(y);  //der Funktion bar den Vektor übergeben
           //-> Besitz wird übertragen 
           
  y.push(5); // Compiler Error	
}</pre>

<pre>
fn bar(x: Vec&lt;i32&gt;) {	
  ...
  //der übergebene Vektor kann wie eine 
  //lokale Variable behandelt werden
  
  //am Ende der Funktion wird x gelöscht und der Speicher freigegeben
}</pre>
		<figcaption>
            <strong>Listing 1</strong>: Übertragung von Ownership an eine Funktion.
        </figcaption>
        </figure>
        <p>
		Das oben stehende Beispiel zeigt, dass anlegen eines Vektors, deren Besitzer die Funktion <code>foo</code> ist und der anschließend an die Funktion <code>bar</code> übergeben wird. Die Funktion <code>bar</code> ist jetzt der neue Besitzer des Vektors und kann die Werte lesen, löschen und zu diesem hinzufügen. Da diese Funktion keinen Rückgabewert besitzt, wird bei Funktionsende der Vektor gelöscht, da er keinen Besitzer mehr hat. In der Funktion <code>foo</code> wird nach dem Aufruf von <code>bar</code> versucht auf den Vektor zuzugreifen, was zu einem Compiler Fehler führt, da <code>foo</code> nicht mehr Besitzer des Vektors ist. Weiterhin ist dieser bereits gelöscht, was zu einem Use After Free führen würde. 
        </p>
        		
		<h3>3.2 Boworring</h3>
		<p>In Rust ist es ebenfalls möglich Speicher zu referenzieren. Man spricht hierbei von Borrowing, da der Besitzt an einer Ressource verliehen bzw. geborgt werden kann. 		
		Verlässt eine Variable, die den Besitz an einer Ressource nur geborgt hat, ihren Gültigkeitsbereich, so wird der Speicher für die die Ressource nicht freigeben, sondern nur die Referenz gelöscht <a href="#r1">[1]</a>. <!-- /references-and-borrowing.html --> Vergleichen lässt sich dieses Konzept mit Zeigern in C++, allerdings gelten für Referenzen in Rust besondere Regeln. Es werden zwei Arten Borrowing unterschieden.
		</p>
		<h4>3.2.1 Shared Borrow</h4>
		<p>
			Beim Shared Borrow, kann der Besitzer dieser Referenz die Ressource nicht verändern. (Auch der Besitzer der Ressource selbst kann diese nicht verändern, solange Referenzen auf diese existieren.)
			Der Referenz wird nur lesender Zugriff auf die Ressource gewährt, allerdings können mehrere Referenzen auf eine Ressource existieren. Man spricht hier auch von Aliasing <a href="#r1">[1]</a>. <!-- /references-and-borrowing.html --> 
			
			<!-- Bsp. für Iterator Invalidation einfügen, falls noch Platz -->
			<!-- Beispielsweise könnte bei einem Array ein Element hinzugefühgt werden, was evtl. da zu führen würde, das auf dem Heap an der aktuellen position nicht genügend Speicherplatz vorhanden ist. Der Vektor würde dann an eine andere Stelle mit ausreichend Speicherplatz (falls vorhanden) verschoben. Damit müssten <strong>alle</strong> anderen Referenzen aktuallieisert werden, um ungültigen Speicherzugriff zu verhindern. Dieses verhalten wird daher beim Shared Borrow verboten. -->
		</p>
		<figure id="li2"> 
<pre>
fn foo() {
  // anlegen eines leeren Vektors für Integerwerte
  let mut y: Vec&lt;i32&gt; = Vec::new();		
  
  y.push(4);  //den Wert 4 zum Vektor hinzufügen
  
  bar(&y);  //der Funktion bar eine unveränderliche Referenz 
            //auf den Vektor übergeben 
           
  y.push(5); // Ok
}</pre>

<pre>
fn bar(x: &Vec&lt;i32&gt;){
  ...	
  b = a + x[0];  // lesender Zugriff ist erlaubt
	
  x.push(1); // Compiler Error
}</pre>
		<figcaption>
            <strong>Listing 2</strong>: Beispiel Shared Borrow.
        </figcaption>
        </figure>
		<p>
			Wie auch in <a href="#li1">Listing 1</a> wir in der Funktion <code>foo</code> ein Vektor angelegt. Hier wird jedoch nur eine unveränderliche Referenz, gekennzeichnet durch das <code>&</code>, der Funktion <code>bar</code> übergeben. Diese kann somit lesend auf den Vektor zugreifen. Schreibender Zugriff ist nicht möglich und führt zu einem Compiler Fehler. Wird <code>bar</code> fehlerfrei beendet, so ist <code>foo</code> weiterhin Besitzer des Vektors. Existieren keine weiteren Referenzen auf diesen, so kann der Vektor auch verändert oder gelöscht werden.  
		</p>
		
		<h4>3.2.2 Mutable Borrow</h4>
		<p>
			Bei Mutable Borrow darf nur eine aktive Referenz auf eine Ressource existieren und der Besitzer dieser Referenz darf die Ressource verändern. Hier wird die Veränderung erlaubt, aber Aliasing verboten. Der Besitz an der Referenz kann übertragen werden.
			Weiterhin dürfen Shared und Mutable Borrow nie gemeinsam auftreten und eine Referenz darf nie länger existieren als der ursprüngliche Besitzer der Ressource. Dies ist vor allem bei der parallelen Programmierung mit mehren Threads zu beachten.
	
		</p>
		<figure id="li3"> 
<pre>
fn foo() {	
  // anlegen eines Vektors für Integer-Werte 
  // mit initialen Werten von 1 bis 5
  let mut y: Vec&lt;i32&gt; = vec![1,2,3,4,5];
  
  // anlegen eines leeren Vektors für Integer-Werte
  let mut x: Vec&lt;i32&gt; = Vec::new();
		
  bar(&y, &mut x); // Ok
  bar(&y, &mut y); // Compiler Error
}</pre>

<pre>
fn bar(y: &Vec&lt;i32&gt;, x: &mut Vec&lt;i32&gt;){
  // diese Funktion kopiert die Werte des ersten übergebenen Vektors 
  // an das Ende des zweiten
  
  for val in y{
    x.push(*val);
  }
  
}</pre>
		<figcaption>
            <strong>Listing 3</strong>: Beispiel Mutable Borrow.
        </figcaption>
        </figure>
        <p>
			In diesem Beispiel werden in der Funktion <code>foo</code> zwei Vektoren angelegt. Die Funktion <code>bar</code> bekommt beide Vektoren als Referenzen, dabei wird <code>y</code> als Shared Borrow und <code>x</code> als Mutable Borrow übergeben. <code>bar</code> kopiert dann den Inhalt des ersten Vektors ans Ende des zweiten. Auf den ersten wird also nur lesend zugegriffen, während der zweite verändert wird. Der Compiler gestattet es nicht, dass zwei Referenzen auf eine Ressource existieren, wobei eine diese verändern darf. Daher kommt es beim zweiten Aufruf der Funktion <code>bar</code> zu einem Compiler Fehler. Somit werden mögliche Data Races schon beim kompilieren verhindert.
        </p>    
    </section>
    
    
    <section id="sec4">
		<h2>4. Vor- und Nachteile von Rust</h2>
		<p>Im folgenden sollen die Vor- und Nachteile der Sprache, die in den vorhergehenden Abschnitten schon angesprochen wurden zusammen gefasst werden.
		</p>
		
		<h3>4.1 Vorteile</h3>
		<p> 
			Ein großer Vorteil von Rust ist, dass viele Fehler, die den Speicherzugriff betreffen schon beim kompilieren erkannt werden können. Erreicht wird dies, durch dass in <a href="#sec3">Kapitel 3</a> vorgestellte Konzept Ownership und Borrowing. Damit ermöglicht Rust sichere systemnahe Programmierung. Die Anwendung dieses Konzepts für die parallele Programmierung, vereinfacht es auch hier, Fehler zu vermeiden.
			Rust eignet sich auch für Programmieranfänger. Der Compiler liefert aussagekräftige Fehlerbeschreibungen, die mit Hilfe von Fehlercodes noch detaillierter und teilweise mit Beispielen versehen erklärt werden.	
			Auch die Funktionalitäten von Funktionalen Programmiersprachen die in Rust enthalten sind machen es sehr komfortable mit Rust zu programmieren.						
			Als Beispiele für diese seine hier Pattern Matching, Traits und Closures genannt.				
<!--
			Patern Matching wird in Rust bspw. bei der Auswertung von Bedingungen eingesetzt. Wo in C++ komplizierte if/else Konstrukte nötig sind, kann dies in Rust meist elegant mit Pattern Matching realisiert werden <a href="#r1">[1]</a>. <!--/match.html-->			
<!--
			Traits ähneln sehr Interfaces in Sparchen, wie C++ oder Java. In der funktionalen Programmiersprache Haskell kann man sie mit den Type Classes vergleichen <a href="#r9">[9]</a>. 		
			Sie bieten die Möglichkeit eine Sammlung von Funktionen zu deklarieren, die für ein Datentypen implementiert werden können <a href="#r1">[1]</a>.  Somit lassen sich Klassen ähnliche Strukturen in Rust definieren. Traits finden sich auch Programmiersprachen, wie PHP oder Perl.		
-->
			Eine genauerer Gegenüberstellung von Rust und funktionalen Programmiersprachen findet sich in <a href="#r9">[9]</a>.
			<!-- evtl. noch FFI -->
			Mit der Sprache selbst kann auch Cargo installiert werden. 
			Cargo ist ein Werkzeug, dass sich hauptsächlich um die Abhängigkeiten und das erstellen der Anwendung kümmert. Dazu lädt Cargo die benötigten Abhängigkeiten für ein Rustprojekt herunter und erstellt dieses, in dem es den Compiler mit den benötigten Parametern aufruft <a href="#r10">[10]</a>. 
			 <!--evtl. noch das mit der .toml konfig datei rein-->
			Mittels Cargo lassen sich auch die Open Source Projekte von crates.io herunterladen und für eigene Anwendungen nutzen. Unter  http://crates.io befindet sich das offizielle Repository für mit Rust geschriebene Bibliotheken (ca. 3.800 Stück, Stand Januar 2016 <a href="#r10">[10]</a> <!-- TODO richtige Quelle angeben! -->).
			Eine wichtige Aufgabe bei der Softwareentwicklung ist die Dokumentation. Auch dafür bringt Rust eine nützliches Werkzeug mit. Mit rustdoc lässt sich eine Dokumentation in HTML  aus dem Quelltext erstellen. Ähnlich, wie mit dem für Java bekannte javadoc.
<!--
			Dazu werden Kommentare in Markdown (einer einfachen Auszeichnungssprache) im Quellcode angegeben oder in einer extra Datei geschrieben  <a href="#r1">[1]</a> <!--/documentation.html-->.  <!-- TODO javadoc --> 
			<!-- Die Dokumentation lässt sich ebenfalls mit Cargo erstellen.
-->
			
			
		 </p>
		 <h3>4.2 Nachteile</h3>
		 <p>
			Die hier aufgeführten Nachteile der Sprache, ergeben sich hauptsächlich daraus, dass Rust noch eine sehr junge Sprache ist. Besonders der Compiler und die Standardbibliothek wird von den Entwicklern ständig erweitert und optimiert. Die Sprache selbst, soll aber ab Version 1.0 stabil gehalten werden und es sollen keine größeren Änderungen mehr erfolgen <a href="#r5">[5]</a>. Besonders vor dieser Version, waren die Nutzer von Rust mit vielen Änderungen konfrontiert.
			Daraus ergibt sich für die Programmierer, die mit Rust arbeiten wollen, dass sie ihren Quellcode gegebenenfalls anpassen müssen. Besonders für größere Projekte kann dies sehr aufwendig und zeitintensiv sein.<br>
			Auf crates.io finden sich viele Bibliotheken für Rust. Diese sind alle Open Source, was bekannte Nachteile mit sich bringt. Ein großer ist die Dokumentation. Bibliotheken, die von den Entwicklern von Rust dort eingestellt werden, sind gut dokumentiert. Einige andere weisen hier Lücken auf, was das programmieren mit diesen erheblich erschwert. Auch die Weiterentwicklung und die Anpassung an Änderungen der Sprache bzw. der Standardbibliothek wird hier zum Problem. Da viele Bibliotheken von Entwicklern in ihrer Freizeit erstellt werden. 	 
		 </p>
    </section>
    <section id="sec5">
		<h2>5. Rust in the Web</h2>
		<p>
			Da bei Rust Sicherheit und Performance im Vordergrund stehen, eignet sich die Sprache besonders für die Entwicklung von Webanwendungen. Auf crates.io finden sich dazu bereits viele bestehende Bibliotheken, die für eigenen Projekte genutzt werden können. Eine Auswahl soll in diesem Kapitel kurz vorgestellt werden.
			Die Möglichkeit einen Server zu programmieren bieten zum Beispiel Hyper und tiny-http. Hyper ist eine in Rust geschriebene HTTP Implementation, die eine typsichere Abstraktion dieses Protokolls bietet. Mit Hyper lassen sich sowohl 
			ein HTTP Server, als auch ein HTTP oder HTTPS Client erstellen <a href="#r11">[11]</a>.
			Mit tiny-http ist es ebenfalls möglich einen HTTP-Server zu erstellen. Bei der Entwicklung von tiny-http wurde viel Wert auf Geschwindigkeit gelegt und bei der Abarbeitung der Anfragen kommt Multithreading zum Einsatz <a href="#r12">[12]</a>.	
			Curl-Rust ist eine Anbindung an die weit verbreitete libcurl Bibliothek für Rust <a href="#r13">[13]</a>. Diese in C geschriebene Bibliothek, wird zur clientseitigen Datenübertragung eingesetzt und unterstützt dazu Protokolle, wie bspw. HTTP, HTTPS, IMAP, POP3, FTP, Telent <a href="#r14">[14]</a>. 
			Der Zugriff auf Datenbanken ist eine häufige Anforderung an eine Webanwendungen. Für Rust gibt es dazu beispielsweise die Bibliotheken Rust-Postgres, usqlite und redis-rs.
			Rust-Postgres kann verwendet werden, wenn eine PostgreSQL Datenbanken genutzt werden soll <a href="#r15">[15]</a>. Für SQLite Datenbanken eignet sich die Bibliothek Rusqlite <a href="#r16">[16]</a>.	Mit redis-rs lassen sich Clients erstellen, um auf Redis Datenbanken zuzugreifen <a href="#r17">[17]</a>. Redis ist eine  In-Memory-Datenbank mit einem Key-Value Datenmodell <a href="#r18">[18]</a>.
<!--
			, wobei viele verschiedenen Arten von Werten unterstützt werden, wie bspw.: Zeichenketten, Listen, Hashes oder auch Bitmaps  
-->
			Um das Entwickeln einer Webanwendung zu vereinfachen, werden meist Webframeworks verwendet. Für Rust gibt es unter anderem die Frameworks <i>Rustful</i>, <i>nickel.rs</i> und <i>Iron</i>.			 
			Rustful ist ein Framework, mit dem Ziel eine einfache und modular aufgebaute Grundlage zu bieten, um HTTP Anwendungen zu programmieren. Rustful eignet sich vor allem, um Anwendungen mit REST APIs zu erstellen <a href="#r20">[20]</a>. 
			Ein weiteres Framework, was zur Erstellung einer Webanwendung genutzt werden kann ist nickel.rs, welches durch das Express Framework für JavaScript inspiriert wurde <a href="#r21">[21]</a>. Das Serverframework Iron wird im nächsten Kapitel genauer vorgestellt und kommt auch in der Demo zum Einsatz.
		</p>
    </section>
    <section id="sec6">
		<h2>6. Iron</h2>
		<p>
<!--
			Iron is a fast and flexible middleware-oriented server framework that provides a small but robust foundation for creating complex applications and RESTful APIs. No middleware are bundled with Iron - instead, everything is drag-and-drop, allowing for ridiculously modular setups. <a href="#r19">[19]</a>
-->
			Iron ist ein schnelles und flexibles Serverframework, welches modular aufgebaut ist und mit dem sich komplexe Anwendungen erstellen lassen <a href="#r19">[19]</a>.			
			Iron ist in Rust geschrieben und basiert auf Hyper.	
			Es kann auf einem Rechner mit einem oder mehreren Threads genutzt werden oder auf mehreren Rechnern verteilt zum Einsatz kommen.
			Das Basisframework ist dabei nicht durch unnötige Funktionalität überladen, sondern lässt sich für eigene Anwendung, mit <i>Middleware</i>, <i>Plugins</i> oder <i>Modifier</i> erweitern.	Middleware kann für Routing, Mounting, Authentifizierung  oder Logging eingesetzt werden. Plugins und Modifier eignen sich, um auf eine  HTTP-Verbindung zuzugreifen oder diese zu manipulieren. Iron bietet die Grundlage, diese Erweiterungen selbst zu erstellen. Es lassen sich auch bereits existierende nutzen, um Satus, Body und verschiedene Header eines Requests oder einer Response zu setzen bzw. auszuwerten <a href="#r22">[22]</a>. 
			Die Middleware <i>urlencoded</i> ermöglicht es, eine Anfrage, welche in die URL ein GET Requests codiert ist, zu verarbeiten. Die übergebenen Parameter stehen nach dem auswerten als Schlüssel-Wert-Paar zur Verfügung <a href="#r23">[23]</a>. Für die Auswertung des Bodys eines POST Requests kann das <i>body-parser</i> Plugin genutzt werden. Dabei werden die an den Server zu übermittelnden Daten in JSON codiert und in den Body des Requests geschrieben. Das Plugin wertet diesen dann aus und stellt die Daten als Struct zur Weiterverarbeitung zur Verfügung <a href="#r24">[24]</a>.	
			Iron wurde in der nachfolgend beschriebenen Demo, zum erstellen eines einfachen Webservers eingesetzt. 		
		</p>
    </section>
    <section id="sec7">
		<h2> 7. Demo </h2>
		<p>
		Um die Sprache Rust und die Funktionsweise von Iron zu demonstrieren wurde eine einfache Client-Server-Anwendung erstellt. Mit dieser sollen zwei, vom Benutzer eingegebene Matrizen an den Server übermittelt werden.  
		Der Server addiert und multipliziert die beiden Matrizen und sendet das Ergebnis an den Client zurück. Das Ergebnis dieser Berechnung oder evtl. auftretende Fehler, werden dann dem Benutzer angezeigt.		
		Der gesamte Quellcode kann unter <a href="#r25">[25]</a> eingesehen und heruntergeladen werden. 
		Die folgende Abbildung zeigt eine Übersicht über die erstellte Demo.
		</p>
		<figure>
          <img src="uebersicht.jpg" alt="Übersicht"/>
          <figcaption>
            <strong>Abbildung 1</strong> Vereinfachte Übersicht der Client-Server-Anwendung.
          </figcaption>
        </figure>
        <h4> Client</h4>
		<p>
		Der Client ist eine Website, in welcher der Benutzer zwei Matrizen eingeben kann. Diese wird vom Server mit allen zusätzlich benötigten Dateien, wie Skripten und Bildern vom Server geladen. Der Benutzer kann dann selbst zwei Matrizen eingeben oder diese randomisiert über das links stehenden Menü erstellen. Klickt der Nutzer auf <i>Berechnen</i>, so wird mittels JavaScript die  Eingabe auf grobe Fehler, wie beispielsweise leere Matrix, Verwendung von Buchstaben oder Fließkommazahlen überprüft und diese dem Benutzer angezeigt. Ist die Eingabe fehlerfrei, so werden beide Matrizen an den Server, mittels POST Request, übermittelt. Die benötigten Daten werden dabei in JSON codiert und in den Body des Requests geschrieben.
		Der Server führt die Berechnungen aus und liefert das Ergebnis ebenfalls als JSON im Body der Response zurück. Diese wird wiederum mittels JavaScript geparsed und dem Benutzer werden die Ergebnisse angezeigt.			
		</p>
		<h4>Server</h4>
		<p>
		Das folgende Bild zeigt schematisch, die Arbeitsweise des erstellten Servers.
		</p>
		<figure>
          <img src="iron_server.jpg" alt="Iron Server"/>
          <figcaption>
            <strong>Abbildung 2</strong>: Vereinfachtes AKtivitätsdiagramm des Servers.
          </figcaption>
        </figure>
		<p>
		Nach dem Start des Servers, wartet dieser auf einen eingehenden Request. 
		Als Vereinfachung, wird bei einem GET Request versucht, die angegebene Datei zu laden und als Response zurück zu senden. Kommt es hier zu einem Fehler, wird ein entsprechender HTTP Fehlercode als Response gesendet. 
		Kommt ein POST Request beim Server an, so wird der Body, falls vorhanden, mit dem body-parser Plugin in ein Struct geparsed, welches dann weiter verarbeitet wird. 
		Falles es hier zu einem Fehler kommt, wird ebenfalls eine Response mit entsprechendem Fehlercode gesendet.
		Im nächsten Schritt werden zwei Threads gestartet. Der erste Thread soll die übergebenen Matrizen Addieren. Ist dies, wegen unterschiedlicher Größe nicht möglich, so liefert der Thread 
		<code>None</code> zurück. Hierbei, wir der von Rust bereitgestellte Datentyp <code>Option&lt;T&gt;</code> genutzt, der es ermöglicht, dass eine Funktion einem Rückgabewert hat oder nicht <a href="#r1">[1]</a>. <!--/error-handling.html-->
		Die Multiplikation läuft simultan in einem zweiten Thread ab und liefert analog, das Ergebnis bzw. <code>None</code>.
		Sind beide Threads beendet, so werden die Ergebnisse ausgewertet und die entsprechende Response mit etwaigen Fehlermeldungen erstellt und zum Client gesendet.
		Der Server wartet im Anschluss auf den nächsten Request.
		</p>		
    </section>
    
<!--
    <section id="sec8">
		<h2>8. Fazit</h2>
		<p>
			Rust ist eine Sprache die viele Funktionalitäten bietet und sich in den nächsten Jahren zu einer sicheren Alternative zu C++ entwickeln könnte.
		</p>
    </section>
-->

	<section class="references" id="sec9">
	   		<h2>8. Literaturverzeichnis</h2>
	   		
	   		<p class="reference" id="r1">[1] The Rust Programming Language [Online]. <br> Available: <a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a> (21.12.2015)</p>
	   		
	   		<p class="reference" id="r2">[2] The Rust Design FAQ [Online]. <br>  Available: <a href="https://doc.rust-lang.org/stable/complement-design-faq.html">https://doc.rust-lang.org/stable/complement-design-faq.html</a> (21.12.2015)</p>
	   		
	   		<p class="reference" id="r3">[3] The Rust Language FAQ [Online]. <br>  Available: <a href="https://doc.rust-lang.org/stable/complement-lang-faq.html">https://doc.rust-lang.org/stable/complement-lang-faq.html</a> (21.12.2015)</p>
	   		
	   		<p class="reference" id="r4">[4] The Rust Project FAQ [Online]. <br>  Available: <a href="https://doc.rust-lang.org/stable/complement-project-faq.html">https://doc.rust-lang.org/stable/complement-project-faq.html</a> (21.12.2015)</p>
	   		
	   		<p class="reference" id="r5">[5] The Rust Core Team (2015, May 15) The Rust Programming Language Blog, Announcing Rust 1.0  [Online]. <br>  Available: <a href="http://blog.rust-lang.org/2015/05/15/Rust-1.0.html">http://blog.rust-lang.org/2015/05/15/Rust-1.0.html</a> (27.12.2015)</p>
	   		
<!-- Youtube -->
			<p class="reference" id="r6">[6]  Linux.conf.au 2015 -- Auckland, New Zealand, Jack Moffitt, "Servo: Building a Parallel Browser", YouTube.com 16.01.2015 [Online]. <br>  Available: <a href="https://www.youtube.com/watch?v=O5vzLKg7y-k">https://www.youtube.com/watch?v=O5vzLKg7y-k</a> (27.12.2015)</p>

	   		<p class="reference" id="r7">[7] stanfordonline, Aaron Turon, "The Rust Programming Language", YouTube.com 12.03.2015 [Online]. <br>  Available: <a href="https://www.youtube.com/watch?v=O5vzLKg7y-k">https://www.youtube.com/watch?v=O5vzLKg7y-k</a> (27.12.2015)</p>
	   		
	   		<p class="reference" id="r8">[8] GoogleTechTalks, Alex Crichton, "The Rust Programming Language", YouTube.com 28.07.2015 [Online]. <br>  Available: <a href="https://www.youtube.com/watch?v=d1uraoHM8Gg">https://www.youtube.com/watch?v=d1uraoHM8Gg</a> (27.12.2015)</p>
<!-- Youtube -->	
	   	  		
	   		<p class="reference" id="r9">[9] Raphael ‘kena’ Poss (2014, July) Rust for functional programmers  [Online]. <br>  Available: <a href="http://science.raphael.poss.name/rust-for-functional-programmers.html">http://science.raphael.poss.name/rust-for-functional-programmers.html</a> (29.12.2015)</p>
	   		
	   		<p class="reference" id="r10">[10] Cargo Guide [Online]. <br> Available: <a href="http://doc.crates.io/guide.html">http://doc.crates.io/guide.html</a> (02.01.2016)</p>
<!--Rust in the web-->  
<!--TODO Autoren !-->
			
			<p class="reference" id="r11">[11] Jonathan Reem, hyper [Online]. <br> Available: <a href="https://github.com/hyperium/hyper">https://github.com/hyperium/hyper</a> (02.01.2016)</p>
	   		
	   		<p class="reference" id="r12">[12] Corey Farwell, tiny-http [Online]. <br> Available: <a href="https://github.com/frewsxcv/tiny-http">https://github.com/frewsxcv/tiny-http</a> (02.01.2016)</p>
	   		
	   		<p class="reference" id="r13">[13] Carl Lerche, Curl-Rust [Online]. <br> Available: <a href="https://github.com/carllerche/curl-rust">https://github.com/carllerche/curl-rust</a> (02.01.2016)</p>
	   		
	   		<p class="reference" id="r14">[14] libcurl [Online]. <br> Available: <a href="http://curl.haxx.se/libcurl">http://curl.haxx.se/libcurl</a> (02.01.2016)</p>
	   		
	   		<p class="reference" id="r15">[15] Steven Fackler, Rust-Postgres  [Online]. <br> Available: <a href="http://sfackler.github.io/rust-postgres/doc/v0.10.2/postgres">http://sfackler.github.io/rust-postgres/doc/v0.10.2/postgres</a> (02.01.2016)</p>
	   		
	   		<p class="reference" id="r16">[16] John Gallagher, Rusqlite  [Online]. <br> Available: <a href="https://github.com/jgallagher/rusqlite">https://github.com/jgallagher/rusqlite</a> (02.01.2016)</p>
	   		
	   		<p class="reference" id="r17">[17] Armin Ronacher, redis-rs  [Online]. <br> Available: <a href="http://mitsuhiko.github.io/redis-rs/redis">http://mitsuhiko.github.io/redis-rs/redis</a> (02.01.2016)</p>
	   		
	   		<p class="reference" id="r18">[18] Salvatore Sanfilippo, Redis [Online]. <br> Available: <a href="https://github.com/antirez/redis">https://github.com/antirez/redis</a> (02.01.2016)</p>
	   		
	   		<p class="reference" id="r19">[19] Michael Sproul, Jonathan Reem, Patrick Tran, Zach Pomerantz, IRON - extensible web framework for rust [Online]. <br> Available: <a href="http://ironframework.io/">http://ironframework.io/</a> (02.01.2016)</p>
	   		
	   		<p class="reference" id="r20">[20] Erik Hedvall, Rustful [Online]. <br> Available: <a href="https://github.com/Ogeon/rustful">https://github.com/Ogeon/rustful</a> (02.01.2016)</p>
				
			<p class="reference" id="r21">[21] Christoph Burgdorf, nickel.rs [Online]. <br> Available: <a href="https://github.com/nickel-org/nickel.rs">https://github.com/nickel-org/nickel.rs</a> (02.01.2016)</p>	
			
			<p class="reference" id="r22">[22] Michael Sproul, Jonathan Reem, Patrick Tran, Zach Pomerantz, Iron - Documentation [Online]. <br> Available: <a href="http://ironframework.io/doc/iron">http://ironframework.io/doc/iron</a> (03.01.2016)</p>	
			
			<p class="reference" id="r23">[23] Michael Sproul, Jonathan Reem, Patrick Tran, Zach Pomerantz, urlencoded [Online]. <br> Available: <a href="https://github.com/iron/urlencoded">https://github.com/iron/urlencoded</a> (04.01.2016)</p>	
			
			<p class="reference" id="r24">[24] Michael Sproul, Jonathan Reem, Patrick Tran, Zach Pomerantz, body-parser [Online]. <br> Available: <a href="https://github.com/iron/body-parser ">https://github.com/iron/body-parser </a>(04.01.2016)</p>
			
			<p class="reference" id="r25">[25] Eric Kunze (2016, January), Rust-Matrix_rechner [Online]. <br> Available: <a href="https://github.com/ekunTUC/rust-matrix-rechner">https://github.com/ekunTUC/rust-matrix-rechner</a> (13.01.2016)</p>
	   		
	</section>
</body>
</html>
